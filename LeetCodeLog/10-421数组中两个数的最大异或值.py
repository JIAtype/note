'''
心得体会：

'''

'''
题目：
给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j < n 。

示例 1：
输入：nums = [3,10,5,25,2,8]
输出：28
解释：最大运算结果是 5 XOR 25 = 28.
示例 2：
输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]
输出：127

提示：
1 <= nums.length <= 2 * 105
0 <= nums[i] <= 231 - 1
'''

'''
解法：
这个问题是“最大异或对”问题，目标是在数组中找到两个数使得它们的异或值最大。

两个二进制位进行异或运算的规则：相同为0，不同为1。

从最高位开始，逐步尝试让答案更大（把某一位设为1）；
利用前缀集快速判断能否达到这个目标；
如果可以，将答案“提升”到这个更高的值；
最后得到整个数组中的最大异或。
'''

'''
以下是代码
'''
class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        ans = mask = 0
# ans：用来存放已经找到的最大异或值。
# mask：用来逐步构建当前考虑的“前缀掩码”，帮助只关注最高几位。        

        high_bit = max(nums).bit_length() - 1
# high_bit：找出数组中最大数字的二进制长度（多少位有效比特），从最高位开始考虑。
# bit_length()会返回二进制长度        

        for i in range(high_bit, -1, -1):  
# 逆序循环，从最高的比特位（比如第4位）开始，到第0位（最低位）结束，逐步试探每一位。

            mask |= 1 << i
# 逐步构建掩码，mask 会逐渐变成像 11111... 这样，保留最高i位。只包含最高到当前位的所有比特，帮我们只关注数字的高位前缀。
# 比如开始时 mask=0，当i=4时， mask |= 1<<4，得到掩码 10000。            
# 1 << i：用位左移操作，把数字1向左移动i位。0001（二进制表示）左移4位 → 10000（二进制）
# |=（位或赋值），是“将右边的值或到左边的变量中。” 把mask和1 << i的二进制位“逐位比较”，不同为1，相同不变

            new_ans = ans | (1 << i)  
# 假设当前最高位的ans是已经找到的最大异或值，加上当前的位 i 试一试能不能让答案偏高。
# 比如试探是否能让第i位变成1，以尝试找到更大的异或。
# |（位或）：把ans的值和1 << i结合，看能不能“提高”最大值的第i位。

            seen = set()
            # 创建一个空集合，记录所有数字的当前前缀（高位部分，根据掩码过滤出来的部分）。
            for x in nums:
                x &= mask  
                # 只保留最高到第 i 位的前缀部分（为了只考虑当前位置以及之前的位）丢弃低位部分。
                if new_ans ^ x in seen:
                    ans = new_ans  
                    break
                # 找是否存在另一个前缀x'，满足：x ^ x' = new_ans
                # 如果new_ans ^ x在seen中，说明存在两个前缀x和x'，它们的异或正好是new_ans。这意味着我们可以实现，把第i位设为1。
                seen.add(x)
        return ans
    




